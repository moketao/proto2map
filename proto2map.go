package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"strings"
	"path/filepath"
)
//https://mholt.github.io/json-to-go/
//https://studygolang.com/articles/6112
type Message struct {
	Name string `json:"name"`
	LongName string `json:"longName"`
	FullName string `json:"fullName"`
	Desc string `json:"description"`
	HasExtensions bool `json:"hasExtensions"`
	HasFields bool `json:"hasFields"`
	Extensions []interface{} `json:"extensions"`
	Code int
	IsEnum bool
	Fields []struct {
		Name string `json:"name"`
		Desc string `json:"description"`
		Label string `json:"label"`
		Type string `json:"type"`
		LongType string `json:"longType"`
		FullType string `json:"fullType"`
		DefaultValue string `json:"defaultValue"`
	} `json:"fields"`
}
type Enum struct {
	Name string `json:"name"`
	LongName string `json:"longName"`
	FullName string `json:"fullName"`
	Desc string `json:"description"`
	IsEnum bool
	Values []struct {
		Name string `json:"name"`
		Number string `json:"number"`
		Desc string `json:"description"`
	} `json:"values"`
}
type File struct {
		Name string `json:"name"`
		Desc string `json:"description"`
		Package string `json:"package"`
		HasEnums bool `json:"hasEnums"`
		HasExtensions bool `json:"hasExtensions"`
		HasMessages bool `json:"hasMessages"`
		HasServices bool `json:"hasServices"`
		Enums []*Enum `json:"enums"`
		Extensions []interface{} `json:"extensions"`
		Messages []*Message `json:"messages"`
		Services []interface{} `json:"services"`
}
type AutoGenerated struct {
	Files []File `json:"files"`
}
var idDic map[string]int
var idFile *string
var templatePath *string
var outputFile *string


func main() {
	templatePath = flag.String("f", "./tpl/MessageIDs.java", " -f your_template_file_name")
	outputFile = flag.String("t", "./java/map/MessageIDs.java", " -t your_output_file")
	idFile = flag.String("j", "./mapids.js", "-j js_file")
	jsonFile := flag.String("data", "./msg.json", " -data your_data_file")
	flag.Parse()

	var e error

	idFileStr, e := ioutil.ReadFile(*idFile)
	if e == nil {
		err := json.Unmarshal([]byte(idFileStr), &idDic)
		ifErr("字典格式不正确：", err)
	}else {
		ioutil.WriteFile(*idFile,[]byte(`{"max_map_proto_id":0}`),0777)	//清空时可用{"max_map_proto_id":0}
	}

	jsonFileBytes, e := ioutil.ReadFile(*jsonFile)
	ifErr("读取数据失败：", e)

	var protoMap map[string]interface{}
	e = json.Unmarshal(jsonFileBytes, &protoMap)
	ifErr("proto集合格式不正确：", e)

	var body AutoGenerated
	e = json.Unmarshal(jsonFileBytes, &body)
	ifErr("解析失败", e)

	for _,file:=range body.Files {
		doFile(&file)
	}
}

func ifErr(str string , err error)  {
	if err != nil {
		fmt.Println(str, err)
		os.Exit(1)
	}
}

func doFile(file *File)  {
	//获取之前记录的已分配的最大id号
	max, ok := idDic["max_map_proto_id"]
	if !ok {
		idDic = make(map[string]int)
		max = 1
	}

	for _, v := range file.Messages {
		//检查所有协议，凡是发现未定义的，都赋给它新的id号
		if _, ok := idDic[v.Name]; !ok {
			idDic[v.Name] = max
			max = max + 1
		}
		var id int
		id = idDic[v.Name]
		v.Code = id
	}

	//再次记录id
	idDic["max_map_proto_id"] = max

	dicBytes, err := json.MarshalIndent(idDic, "", "	")
	ifErr("出错了",err)
	ioutil.WriteFile(*idFile, dicBytes, 0777)

	f, err := os.OpenFile(*outputFile, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0777)
	ifErr("创建文件出错",err)

	t1, err := template.New(filepath.Base(*templatePath)).Funcs(template.FuncMap{
		"hasSuffix": HasSuffix,
		"hasPrefix": HasPrefix,
	}).ParseFiles(*templatePath)
	ifErr("模板执行出错",err)
	t1.Execute(f, *file)
}

func HasSuffix(s string,suffix string) bool  {
	return strings.HasSuffix(s,suffix)
}
func HasPrefix(s string,prefix string) bool  {
	return strings.HasPrefix(s,prefix)
}
